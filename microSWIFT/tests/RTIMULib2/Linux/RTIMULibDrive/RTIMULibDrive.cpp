////////////////////////////////////////////////////////////////////////////
//
//  This file is part of RTIMULib
//
//  Copyright (c) 2014-2015, richards-tech, LLC
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy of
//  this software and associated documentation files (the "Software"), to deal in
//  the Software without restriction, including without limitation the rights to use,
//  copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
//  Software, and to permit persons to whom the Software is furnished to do so,
//  subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in all
//  copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
//  INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
//  PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
//  HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
//  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
//  SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


#include <iostream>

#include "RTIMULib.h"

const std::string currentDateTime() {
  char            fmt[64], buf[64];
  struct timeval  tv;
  struct tm       *tm;

  gettimeofday(&tv, NULL);
  tm = localtime(&tv.tv_sec);
  strftime(fmt, sizeof fmt, "%Y-%m-%d %H:%M:%S.%%06u", tm);
  snprintf(buf, sizeof buf, fmt, tv.tv_usec);
  return buf;
}

int main()
{
  int sampleCount = 0;
  int sampleRate = 0;
  uint64_t rateTimer;
  uint64_t displayTimer;
  uint64_t now;


  //  Using RTIMULib here allows it to use the .ini file generated by RTIMULibDemo.
  //  Or, you can create the .ini in some other directory by using:
  //      RTIMUSettings *settings = new RTIMUSettings("<directory path>", "RTIMULib");
  //  where <directory path> is the path to where the .ini file is to be loaded/saved

  RTIMUSettings *settings = new RTIMUSettings("RTIMULib");

  RTIMU *imu = RTIMU::createIMU(settings);
  RTPressure *pressure = RTPressure::createPressure(settings);
  RTHumidity *humidity = RTHumidity::createHumidity(settings);

  if ((imu == NULL) || (imu->IMUType() == RTIMU_TYPE_NULL)) {
    printf("No IMU found\n");
    exit(1);
  }

  //  This is an opportunity to manually override any settings before the call IMUInit

  //  set up IMU

  imu->IMUInit();

  //  this is a convenient place to change fusion parameters

  imu->setSlerpPower(0.02);
  imu->setGyroEnable(true);
  imu->setAccelEnable(true);
  imu->setCompassEnable(true);

  // set up pressure sensor 

  if (pressure != NULL) {
    pressure->pressureInit();
  }

  //  set up humidity sensor

  if (humidity != NULL) {
    humidity->humidityInit();
  }

  rateTimer = displayTimer = RTMath::currentUSecsSinceEpoch();

  //  now just process data

  while (1) {
    //  poll at the rate recommended by the IMU

    usleep(imu->IMUGetPollInterval() * 1000);

    while(imu->IMURead()) {
      sampleCount++;
      RTIMU_DATA m_imuData = imu->getIMUData();

      if (pressure != NULL) {
        pressure->pressureRead(m_imuData);
      }

      if (humidity != NULL) { 
        humidity->humidityRead(m_imuData);
      }

      now = RTMath::currentUSecsSinceEpoch();

      if ((now - displayTimer) > 100000) {

        std::cout << currentDateTime() << " ";
        std::cout << "pressure = " << m_imuData.pressure << std::endl; 

        std::cout << currentDateTime() << " ";
        std::cout << "gyro_x = " << m_imuData.gyro.x() << ", ";
        std::cout << "gyro_y = " << m_imuData.gyro.y() << ", ";
        std::cout << "gyro_z = " << m_imuData.gyro.z() << std::endl;

        std::cout << currentDateTime() << " ";
        std::cout << "accel_x = " << m_imuData.accel.x() << ", ";
        std::cout << "accel_y = " << m_imuData.accel.y() << ", ";
        std::cout << "accel_z = " << m_imuData.accel.z() << std::endl;

        std::cout << currentDateTime() << " ";
        std::cout << "compass_x = " << m_imuData.compass.x() << ", ";
        std::cout << "compass_y = " << m_imuData.compass.y() << ", ";
        std::cout << "compass_z = " << m_imuData.compass.z() << std::endl;

        std::cout << currentDateTime() << " ";
        std::cout << "angle_x = " << m_imuData.fusionPose.x() * RTMATH_RAD_TO_DEGREE << ", ";
        std::cout << "angle_y = " << m_imuData.fusionPose.y() * RTMATH_RAD_TO_DEGREE << ", ";
        std::cout << "angle_z = " << m_imuData.fusionPose.z() * RTMATH_RAD_TO_DEGREE << std::endl;

        std::cout << currentDateTime() << " ";
        std::cout << "scalar = " << m_imuData.fusionQPose.scalar() << ", ";
        std::cout << "quaternion_x = " << m_imuData.fusionQPose.x() << ", ";
        std::cout << "quaternion_y = " << m_imuData.fusionQPose.y() << ", ";
        std::cout << "quaternion_z = " << m_imuData.fusionQPose.z() << std::endl;

        std::cout << currentDateTime() << " ";
        std::cout << "accelMagnitude = " << m_imuData.accel.length() << ", ";
        std::cout << "compassMagnitude = " << m_imuData.compass.length() << std::endl;

        if (m_imuData.pressureValid) {
          std::cout << currentDateTime() << " ";
          std::cout << "pressure = " << m_imuData.pressure << ", ";
          std::cout << "height = " << RTMath::convertPressureToHeight(m_imuData.pressure) << std::endl;
        }

        if (m_imuData.humidityValid) {
          std::cout << currentDateTime() << " ";
          std::cout << "humidity = " << m_imuData.humidity << std::endl;
        }

        if (m_imuData.humidityValid) {
          std::cout << currentDateTime() << " ";
          std::cout << "temperature = " << m_imuData.temperature << std::endl;
        }

        RTVector3 residuals = imu->getAccelResiduals();

        std::cout << currentDateTime() << " ";
        std::cout << "accelResidual_x = " << residuals.x() << ", ";
        std::cout << "accelResidual_y = " << residuals.y() << ", ";
        std::cout << "accelResidual_z = " << residuals.z() << std::endl;

        return 0; // exit
      }

      if ((now - rateTimer) > 1000000) {
        sampleRate = sampleCount;
        sampleCount = 0;
        rateTimer = now;
      }
    }
  }
}
